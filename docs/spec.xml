<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
        <!ENTITY rfc3447 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3447.xml">
        <!ENTITY rfc4648 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml">
        <!ENTITY rfc4871 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.4871.xml">
        <!ENTITY rfc3110 SYSTEM "http://xml.resource.org/public/rfc/bibxml/reference.RFC.3110.xml">
        <!ENTITY I-D.draft-irtf-cfrg-eddsa-04 SYSTEM "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.draft-irtf-cfrg-eddsa-04.xml">
        ]>
<?xml-stylesheet type="text/xsl" href="rfc2629.xsl" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>
<?rfc toc="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc symrefs="yes" ?>
<rfc category="std" ipr="trust200902" submissionType="independent"
     docName="draft-thomas-crypto-conditions-01">
    <front>
        <title>Crypto-Conditions</title>

        <author initials="S." surname="Thomas" fullname="Stefan Thomas">
            <organization>Ripple</organization>
            <address>
                <postal>
                    <street>300 Montgomery Street</street>
                    <city>San Francisco</city> <region>CA</region>
                    <code>94104</code>
                    <country>US</country>
                </postal>
                <phone>-----------------</phone>
                <email>stefan@ripple.com</email>
                <uri>http://www.ripple.com/</uri>
            </address>
        </author>

        <date month="March" year="2016" />
        <area>Security</area>
        <workgroup></workgroup>
        <keyword>digital signature</keyword>
        <keyword>event-driven architecture</keyword>
        <keyword>PKI</keyword>
        <abstract>
            <t>
                Crypto-conditions provide a mechanism to describe a signed message such that multiple actors in a
                distributed system can all verify the same signed message and agree on whether it matches the
                description.

                This provides a useful primitive for event-based systems that are distributed on the Internet
                since we can describe events in a standard deterministic manner (represented by signed messages)
                and therefore define generic authenticated event handlers.
            </t>
        </abstract>
        <note title="Feedback">
            <t>
                This specification is a part of the
                <eref target="https://interledger.org/">Interledger Protocol</eref> work. Feedback
                related to this specification should be sent to
                <eref target="mailto:public-interledger@w3.org">public-interledger@w3.org</eref>.
            </t>
        </note>
    </front>

    <middle>

        <section anchor="intro" title="Introduction">
            <t>
                This specification describes a message format for defining distributable event
                descriptions (crypto-conditions) and the cryptographically verifiable event messages
                (fulfillments) that can be used to prove that the event occured.
            </t>
            <t>
                The specification defines both binary and string-based encoding for the messages.
            </t>
            <section anchor="terminology" title="Terminology">
                <t>
                    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
                    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
                    document are to be interpreted as described in [RFC2119].
                </t>
                <t>
                    Within this specification, the term "condition" refers to the hash of a
                    description of a signed message.
                </t>

                <t>
                    The term "fulfillment" refers to a description of a signed message
                    and a signed message that matches the description.
                </t>
                <t>
                    The description can be hashed and compared to a condition. If the
                    message matches the description and the hash of the description matches
                    the condition, we say that the fulfillment fulfills the condition.
                </t>
                <t>
                    A "hashlock" is a tuple consisting of a bytestring and its hash where the
                    hash is published first and the publication of the corresponding bytestring
                    acts as a one-bit, one-time signature.
                </t>
            </section>

            <section anchor="features" title="Features">
                <t>
                    Crypto-conditions are a simple multi-algorithm, multi-message, multi-level,
                    multi-signature standard format for expressing conditions and fulfillments.
                </t>

                <section anchor="multi-algorithm" title="Multi-Algorithm">
                    <t>
                        Crypto-conditions can support several different signature and hash algorithms
                        and support for new ones can be added in the future.
                    </t>
                    <t>
                        <figure>
                            <preamble>
                                Implementations can state their supported algorithms simply by providing a
                                bitmask. It is easy to verify that a given implementation will be able to
                                verify the fulfillment to a given condition, by verifying that the condition's
                                bitmask and its own bitmask of supported algorithms satisfies:
                            </preamble>
                            <artwork><![CDATA[
condition &amp; ~supported == 0
                         ]]></artwork>
                            <postamble>
                                where &amp; is the bitwise AND operator and ~ is the bitwise NOT operator.
                            </postamble>
                        </figure>
                    </t>
                    <t>
                        Any new high bit can redefine the meaning of any existing lower bits as long as
                        it is set. This can be used to remove obsolete algorithms.
                    </t>
                    <t>
                        The bitmask is encoded as a varint to minimize space usage.
                    </t>
                    <t>By evaluating the bitmask of a condition actors in the system can establish, even before
                    a fulfillment is published, if they will be able to verify the fulfilment.</t>
                </section>
                <section anchor="multi-signature" title="Multi-Signature">
                    <t>
                        Crypto-conditions can abstract away many of the details of multi-sign. When a party
                        provides a condition, other parties can treat it opaquely and do not need to know
                        about its internal structure. That allows parties to define arbitrary multi-signature
                        setups without breaking compatibility.
                    </t>
                    <t>
                        Protocol designers can use crypto-conditions as a drop-in replacement for public key
                        signature algorithms and add multi-signature support to their protocols without adding
                        any additional complexity.
                    </t>
                </section>
                <section anchor="multi-level" title="Multi-Level">
                    <t>
                        Basic multi-sign is single-level and does not support more complex trust relationships
                        such as "I trust Alice and Bob, but only when Candice also agrees". In single level
                        2-of-3 Alice and Bob could sign on their own, without Candice's approval.
                    </t>
                    <t>
                        Crypto-conditions add that flexibility elegantly, by applying thresholds not just to
                        signatures, but to conditions which can be signatures or further conditions. That
                        allows the creation of an arbitrary threshold boolean circuit of signatures.
                    </t>
                </section>
                <section anchor="multi-message" title="Multi-Message">
                    <t>
                        Crypto-conditions can sign not just one, but multiple messages at the same time and
                        by different people. These messages can then be used as inputs for other algorithms.
                    </t>
                    <t>
                        This allows resource-controlling systems to perform their functions without knowing the
                        details of the higher-level protocols that these functions are a part of.
                    </t>
                </section>
            </section>

        </section>

        <section title="Format" anchor="format">
            <t>
                Conditions and fulfillments are expressed in a standard format with both string and binary
                encoding supported.
            </t>
            <section title="Bitmask" anchor="bitmask">
                <t>
                    Any system accepting crypto-conditions must be able to state its supported algorithms. It
                    must be possible to verify that all algorithms used in a certain condition are indeed
                    supported even if the fulfillment is not available yet.
                </t>
                <t>
                    In order to meet these design goals, we define a bitmask to express the supported
                    primitives.
                </t>
                <t>
                    Each bit represents a different crypto-condition type. The list of known types is
                    maintained in the IANA maintained <xref target="crypto-conditions-type-registry">
                    Crypto-Condition Type Registry</xref>.
                </t>
                <t>
                    Conditions contain a bitmask of types which they require the implementation to support.
                    Implementations provide a bitmask of types they support.
                </t>

            </section>
            <section anchor="binary-types" title="Binary Types">
                <t>
                    <list hangIndent="8" style="hanging">
                        <t hangText="VARUINT">
                            Unsigned variable-length integer. Implementation matches Base128 Varints in Protocol Buffers
                            <xref target="PROTOCOL-BUFFERS"/>. Implementations MAY define different maximum lengths for
                            their varints, as long as that length is long enough to cover their bitmask and their
                            maximum supported fulfillment length. (This is safe, because no larger varuint can
                            appear in a valid crypto-condition.)
                        </t>

                        <t hangText="VARBYTES">
                            Consists of a VARUINT length field followed by that many bytes.
                        </t>

                        <t hangText="VARARRAY">
                            Consists of a VARUINT length fields followed by that many bytes filled with
                            elements of the array.
                        </t>
                    </list>
                </t>
            </section>
            <section anchor="string-types" title="String Types">
                <t>
                    <list hangIndent="8" style="hanging">
                        <t hangText="BASE10">
                            Variable-length integer encoded as a base-10 (decimal) number. Implementations
                            MUST reject encodings that are too large for them to parse. Implementations MUST be tested for
                            overflows.
                        </t>

                        <t hangText="BASE16">
                            Variable-length integer encoded as a base-16 (hexadecimal) number. Implementations
                            MUST reject encodings that are too large for them to parse. Implementations MUST be
                            tested for overflows. No leading zeros.
                        </t>

                        <t hangText="BASE64URL">
                            Base64-URL encoding. See <xref target="RFC4648"/>, Section 5.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Condition" anchor="condition-format">
                <t>
                    Below are the string and binary encoding formats for a condition. In both, the TYPE_BITMASK
                    is the boolean OR of the TYPE_BITs of the condition type and all subcondition types,
                    recursively.
                </t>
                <section title="String" anchor="string-condition-format">
                    <figure>
                        <preamble>
                            Conditions are ASCII encoded as:
                        </preamble>
                        <artwork><![CDATA[
"cc:" BASE10(VERSION) ":" BASE16(TYPE_BITMASK) ":"
    BASE64URL(HASH) ":" BASE10(MAX_FULFILLMENT_LENGTH)
                     ]]></artwork>
                    </figure>
                </section>
                <section title="Binary Format" anchor="binary-condition-format">
                    <figure>
                        <preamble>
                            Conditions are binary encoded as:
                        </preamble>
                        <artwork><![CDATA[
CONDITION =
  VARUINT TYPE_BITMASK
  VARBYTES HASH
  VARUINT MAX_FULFILLMENT_LENGTH
                     ]]></artwork>
                    </figure>
                </section>
            </section>
            <section title="Fulfillment" anchor="fulfillment-format">
                <t>
                    Below are the string and binary encoding formats for a fulfillment. In both the
                    TYPE_BIT is the single bit representing the top level condition type.
                </t>
                <section title="String Format" anchor="string-fulfillment-format">
                    <figure>
                        <preamble>
                            Fulfillments are ASCII encoded as:
                        </preamble>
                        <artwork><![CDATA[
"cf:" BASE10(VERSION) ":" BASE16(TYPE_BIT) ":"
    BASE64URL(FULFILLMENT_PAYLOAD)
                     ]]></artwork>
                    </figure>
                </section>
                <section title="Binary Format" anchor="binary-fulfillment-format">
                    <figure>
                        <preamble>
                            Fulfillments are binary encoded as:
                        </preamble>
                        <artwork><![CDATA[
FULFILLMENT =
  VARUINT TYPE_BIT
  FULFILLMENT_PAYLOAD
                     ]]></artwork>
                    </figure>
                </section>
            </section>
        </section>
        <section title="Condition Types" anchor="condition-types">
            <t>
                The following condition types are defined in this version of the specification. New types may
                be defined in future and will be registered in the IANA maintained <xref
                    target="crypto-conditions-type-registry">Crypto-Condition Type Registry</xref>
            </t>
            <section title="SHA-256" anchor="sha-256-condition-type">
                <t>
                    SHA-256 is assigned the type bit 2^0 = 0x01.
                </t>
                <t>
                    This type of condition is also called a hashlock. We can use revealing the preimage as
                    a type of one bit signature.
                </t>
                <t>
                    Bitcoin supports this type of condition via the OP_HASH256 operator.
                </t>
                <section title="Condition" anchor="sha-256-condition-type-condition">
                    <figure>
                        <artwork><![CDATA[
HASH = SHA256(PREIMAGE)
                     ]]></artwork>
                    </figure>
                </section>
                <section title="Fulfillment" anchor="sha-256-condition-type-fulfillment">
                    <figure>
                        <artwork><![CDATA[
FULFILLMENT_PAYLOAD =
  VARBYTES PREIMAGE
                     ]]></artwork>
                    </figure>
                </section>
            </section>
            <section title="RSA-SHA-256" anchor="rsa-sha-256-condition-type">
                <t>
                    RSA-SHA-256 is assigned the type bit 2^1 = 0x02.
                </t>
                <section title="Condition" anchor="rsa-sha-256-condition-type-condition">
                    <figure>
                        <artwork><![CDATA[
HASH = SHA256(
  VARBYTES MODULUS
  VARBYTES MESSAGE_ID
  VARBYTES FIXED_PREFIX
  VARUINT DYNAMIC_MESSAGE_LENGTH
)
                     ]]></artwork>
                    </figure>
                    <t>
                        The MODULUS is the RSA public modulus. The public exponent e is set to 65537 as
                        recommended in <xref target="RFC4871" />. Very large exponents can be a DoS
                        vector <xref target="LARGE-RSA-EXPONENTS"/> and 65537 is the largest Fermat prime,
                        which has some nice properties <xref target="USING-RSA-EXPONENT-OF-65537"/>.
                    </t>
                    <t>
                        Implementations MUST reject moduli smaller than 128 bytes (1017 bits) or greater
                        than 512 bytes (4096 bits.) Large moduli slow down signature verification which can be
                        a DoS vector. DNSSEC also limits the modulus to 4096 bits <xref target="RFC3110"/>.
                        OpenSSL supports up to 16384 bits <xref target="OPENSSL-X509-CERT-EXAMPLES" />.
                    </t>
                </section>
                <section title="Fulfillment" anchor="rsa-sha-256-condition-type-fulfillment">
                    <figure>
                        <artwork><![CDATA[
FULFILLMENT_PAYLOAD =
  VARBYTES MODULUS
  VARBYTES MESSAGE_ID
  VARBYTES FIXED_PREFIX
  VARUINT DYNAMIC_MESSAGE_LENGTH
  VARBYTES DYNAMIC_MESSAGE
  VARBYTES SIGNATURE
                     ]]></artwork>
                    </figure>
                    <t>
                        The SIGNATURE must have the exact same number of octets as the MODULUS. So
                        theoretically we could omit the length prefix for the SIGNATURE field. But for
                        consistency, we include the length prefix. Implementations MUST verify that the
                        SIGNATURE and MODULUS are of the same length.
                    </t>
                    <t>
                        The DYNAMIC_MESSAGE_LENGTH is included to provide a maximum length for DYNAMIC_MESSAGE
                        even if the actual message suffix length is different. This value is used to calculate
                        the MAX_FULFILLMENT_LENGTH in the condition.
                    </t>
                    <t>
                        The MESSAGE_ID represents an identifier for the message. All messages in a
                        cryptocondition that have a common identifier must match, otherwise the condition is
                        invalid. Implementations may return messages as a map of MESSAGE_ID => MESSAGE pairs.
                    </t>
                    <t>
                        The message to be signed is the concatenation of the FIXED_PREFIX and DYNAMIC_MESSAGE.
                    </t>
                </section>
                <section title="Implementation" anchor="rsa-sha-256-condition-type-implementation">
                    <t>
                        The signature algorithm used is RSASSA-PSS as defined in PKCS#1 v2.2.
                        <xref target="RFC3447" />
                    </t>
                    <t>
                        The recommended modulus size as of 2016 is 2048 bits <xref target="KEYLENGTH-RECOMMENDATION"/>.
                        In the future we anticipate an upgrade to 3072 bits which provides approximately 128 bits of
                        security <xref target="NIST-KEYMANAGEMENT"/>(p. 64), about the same level as SHA-256.
                    </t>
                    <t>
                        The salt length for PSS is 32 bytes.
                    </t>
                </section>
            </section>
            <section title="THRESHOLD-SHA-256" anchor="threshold-sha-256-condition-type">
                <t>
                    THRESHOLD-SHA-256 is assigned the type bit 2^2 = 0x04.
                </t>
                <section title="Condition" anchor="threshold-sha-256-condition-type-condition">
                    <figure>
                        <artwork><![CDATA[
HASH = SHA256(
  VARUINT TYPE_BIT
  VARUINT THRESHOLD
  VARARRAY
    VARUINT WEIGHT
    CONDITION
)
                     ]]></artwork>
                    </figure>
                    <t>
                        The TYPE_BIT is 0x04. The reason we need this is because threshold conditions are a
                        structural condition. Structural conditions can have subconditions, meaning their
                        TYPE_BITMASK can have multiple bits set, including other structural conditions. This
                        TYPE_BIT prevents the possibility that two different structural fulfillments could
                        ever generate the exact same condition.
                    </t>
                    <t>
                        The VARARRAY of conditions is sorted first based on length, shortest first. Elements of the
                        same length are sorted in lexicographic (big-endian) order, smallest first.
                    </t>
                </section>
                <section title="Fulfillment" anchor="threshold-sha-256-condition-type-fulfillment">
                    <figure>
                        <artwork><![CDATA[
ULFILLMENT_PAYLOAD =
  VARUINT THRESHOLD
  VARARRAY
    VARUINT WEIGHT
    FULFILLMENT
  VARARRAY
    VARUINT WEIGHT
    CONDITION
                     ]]></artwork>
                    </figure>
                </section>
            </section>
            <section title="ED25519-SHA-256" anchor="ed25519-sha-256-condition-type">
                <t>
                    ED25519-SHA-256 is assigned the type bit 2^3 = 0x08.
                </t>
                <section title="Condition" anchor="ed25519-sha-256-condition-type-condition">
                    <figure>
                        <artwork><![CDATA[
HASH = SHA256(
  VARBYTES PUBLIC_KEY
  VARBYTES MESSAGE_ID
  VARBYTES FIXED_PREFIX
  VARUINT DYNAMIC_MESSAGE_LENGTH
)
                     ]]></artwork>
                    </figure>
                </section>
                <section title="Fulfillment" anchor="ed25519-sha-256-condition-type-fulfillment">
                    <figure>
                        <artwork><![CDATA[
FULFILLMENT_PAYLOAD =
  VARBYTES PUBLIC_KEY
  VARBYTES MESSAGE_ID
  VARBYTES FIXED_PREFIX
  VARUINT DYNAMIC_MESSAGE_LENGTH
  VARBYTES DYNAMIC_MESSAGE
  VARBYTES SIGNATURE
                     ]]></artwork>
                    </figure>
                    <t>
                        The MESSAGE_ID, FIXED_PREFIX, DYNAMIC_MESSAGE_LENGTH and DYNAMIC_MESSAGE fields have the same
                        meaning as in the RSA-SHA-256 condition type.
                    </t>
                </section>
                <section title="Implementation" anchor="ed25519-sha-256-condition-type-implementation">
                    <t>
                        The exact algorithm and encodings used for PUBLIC_KEY and SIGNATURE are Ed25519 as defined in
                        <xref target="I-D.irtf-cfrg-eddsa" />
                    </t>
                </section>
            </section>
        </section>

    </middle>
    <back>
        <references title="Normative References">
            &rfc3447;
            &rfc4648;
            &I-D.draft-irtf-cfrg-eddsa-04;
            <reference anchor="PROTOCOL-BUFFERS"
                       target="https://developers.google.com/protocol-buffers/docs/encoding#varints">
                <front>
                    <title>Protocol Buffers - Encoding - Base128 VARINTS</title>
                    <author fullname="Google Developers"/>
                    <date day="20" month="01" year="2016"/>
                </front>
            </reference>
        </references>
        <references title="Informative References">
            &rfc3110;
            &rfc4871;
            <reference anchor="LARGE-RSA-EXPONENTS" target="https://www.imperialviolet.org/2012/03/17/rsados.html">
                <front>
                    <title>Imperial Violet - Very large RSA public exponents (17 Mar 2012)</title>
                    <author fullname="Adam Langley"/>
                    <date day="17" month="03" year="2012"/>
                </front>
            </reference>
            <reference anchor="USING-RSA-EXPONENT-OF-65537"
                       target="http://crypto.stackexchange.com/questions/3110/impacts-of-not-using-rsa-exponent-of-65537">
                <front>
                    <title>Cryptography - StackExchange - Impacts of not using RSA exponent of 65537</title>
                    <author fullname="http://crypto.stackexchange.com/users/555/fgrieu"/>
                    <date day="18" month="11" year="2014"/>
                </front>
            </reference>
            <reference anchor="KEYLENGTH-RECOMMENDATION"
                       target="https://www.keylength.com/en/compare/">
                <front>
                    <title>BlueKrypt - Cryptographic Key Length Recommendation</title>
                    <author fullname="Damien Giry"/>
                    <date day="17" month="09" year="2015"/>
                </front>
            </reference>
            <reference anchor="NIST-KEYMANAGEMENT"
                       target="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57_part1_rev3_general.pdf">
                <front>
                    <title>NIST - Recommendation for Key Management - Part 1 - General (Revision 3)</title>
                    <author fullname="Elaine Barker"/>
                    <author fullname="William Barker"/>
                    <author fullname="William Burr"/>
                    <author fullname="William Polk"/>
                    <author fullname="Miles Smid"/>
                    <date month="07" year="2012"/>
                </front>
            </reference>
            <reference anchor="OPENSSL-X509-CERT-EXAMPLES"
                       target="http://fm4dd.com/openssl/certexamples.htm">
                <front>
                    <title>OpenSSL - X509 certificate examples for testing and verification</title>
                    <author fullname="FM4DD"/>
                    <date month="07" year="2012"/>
                </front>
            </reference>
        </references>
        <section anchor="appendix-a" title="Security Considerations">
            <t>
                <!-- There are a number of security considerations to take into account when implementing
                or utilizing this specification. A thorough security analysis of this protocol,
                including its strengths and weaknesses, can be found in
                <eref target="">
                    Security Considerations for Crypto-Conditions</eref>.
                    -->
                TODO
            </t>
        </section>

        <section anchor="appendix-b" title="Test Values">
            <t>
                TODO
            </t>
        </section>
        <section anchor="acknowledgements" title="Acknowledgements">
            <t>
                The editor would like to thank the following individuals for feedback on and
                implementations of the specification (in alphabetical order): TODO
            </t>
        </section>
        <section anchor="appendix-c" title="IANA Considerations">
            <section anchor="crypto-conditions-type-registry" title="Crypto-Condition Type Registry">
                <t>
                    The following initial entries should be added to the Crypto-Condition
                    Type registry to be created and maintained at (the suggested URI)
                    <eref target="http://www.iana.org/assignments/crypto-condition-types">
                        http://www.iana.org/assignments/crypto-condition-types</eref>:
                </t>

                <texttable anchor="crypto-condition-type-bitmasks" title="Crypto-Condition Type Bitmasks">
                    <preamble>The following bitmasks are registered:</preamble>

                    <ttcol align="right">Type Bit</ttcol>

                    <ttcol align="right">Exp.</ttcol>

                    <ttcol align="right">Int.</ttcol>

                    <ttcol align="right">Condition Type.</ttcol>

                    <c>1</c>

                    <c>2^0</c>

                    <c>1</c>

                    <c>SHA-256</c>

                    <c>10</c>

                    <c>2^1</c>

                    <c>2</c>

                    <c>RSA-SHA-256</c>

                    <c>100</c>

                    <c>2^2</c>

                    <c>4</c>

                    <c>THRESHOLD-SHA-256</c>

                    <c>1000</c>

                    <c>2^3</c>

                    <c>8</c>

                    <c>ED25519-SHA-256</c>

                </texttable>
            </section>
        </section>
    </back>
</rfc>
